# Build project docker image, extract sourcemaps and push image to project container registry
.docker-build: &docker-build
  image: $DOCKER_IMAGE
  tags:
    - docker-privileged
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    IMAGE_TAG: ${CI_REGISTRY}/${CI_PROJECT_PATH}:${APP}_${ENVIRONMENT}
    RELEASE_TAG: $RELEASE_TAG
    DOCKERFILE: Dockerfile
  services:
    - $DIND_SERVICE_IMAGE
  before_script:
    - docker info
  script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN ${CI_REGISTRY}
    - docker pull ${IMAGE_TAG} || true
    - echo "Building docker image from git tag $RELEASE_TAG with image tag ${IMAGE_TAG}"
    - docker build --cache-from ${IMAGE_TAG} --build-arg env=${ENVIRONMENT} --build-arg release_tag=$RELEASE_TAG -t ${IMAGE_TAG} ${APP}/. -f ${APP}/${DOCKERFILE}
    - docker push ${IMAGE_TAG}
    # Extract sourcemaps from docker image if frontend image
    - if [ "${DOCKERFILE}" == "Dockerfile.frontend" ]; then mkdir sourcemaps && docker cp $(docker create --rm ${IMAGE_TAG}):/usr/share/caddy/js/. sourcemaps ; fi
  artifacts:
    paths:
      - sourcemaps/
    expire_in: 1 week

# Copy deploy folder to given target server and run scripts.sh.
.docker-deploy: &docker-deploy
  image: $DEPLOY_IMAGE
  variables:
    DEPLOY_COMMAND: "cd /home/manager/srv/app/scripts/; chmod u+x deploy.sh; ./deploy.sh ${CI_DEPLOY_USER} ${CI_DEPLOY_PASSWORD} ${CI_REGISTRY} ${CI_PROJECT_PATH} ${ENVIRONMENT}"
  environment:
    name: ${ENVIRONMENT}
    url: https://$DOMAIN
  before_script:
    - apk add --no-cache rsync
    - 'which ssh-agent || ( apk add --no-cache openssh-client )'
    - eval $(ssh-agent -s)
    - echo "$DEPLOYMENT_SSH_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - '[[ -f /.dockerenv ]] && echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config'
  script:
    - ssh -p $SSH_PORT manager@${DOMAIN} "mkdir -p ~/srv/app/"
    - rsync -r -e "ssh -p ${SSH_PORT}" ./deploy/ manager@${DOMAIN}:~/srv/app/
    - if [ "$SKIP_DEPLOY" = "True" ]; then exit 0; fi
    - ssh -p $SSH_PORT manager@$DOMAIN $DEPLOY_COMMAND
  tags:
    - docker-privileged

# Pull forge helm chart and deploy to a k8s cluster.
.k8s-deploy: &k8s-deploy
  image:
    name: alpine/helm
    entrypoint: [""]
  tags:
    - docker-privileged
  before_script:
    - export KUBECONFIG=${KUBE_CONFIG_FILE}
  script:
    - echo $FRONTEND_DOMAIN
    - echo $BACKEND_DOMAIN
    - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.liip.ch/amboss/ambops/forge-helm-chart.git
    - helm dependency update forge-helm-chart/charts/backend
    - >
      helm upgrade --install --namespace ${ENVIRONMENT_NAMESPACE}
      --set "frontend.image.suffix=${IMAGE_SUFFIX}"
      --set "backend.image.suffix=${IMAGE_SUFFIX}"
      --set "frontend.ingress.hosts[0].host=$FRONTEND_DOMAIN"
      --set "backend.ingress.hosts[0].host=$BACKEND_DOMAIN"
      --set "frontend.ingress.tls[0].hosts[0]=$FRONTEND_DOMAIN"
      --set "backend.ingress.tls[0].hosts[0]=$BACKEND_DOMAIN"
      --set "configmap.data.FRONTEND_DOMAIN=$FRONTEND_DOMAIN"
      --set "configmap.data.BACKEND_DOMAIN=$BACKEND_DOMAIN"
      --set "configmap.data.ALLOWED_HOSTS=$BACKEND_DOMAIN"
      --set "configmap.data.CORS_ORIGIN_WHITELIST=$BACKEND_DOMAIN"
      --create-namespace ${ENVIRONMENT_NAMESPACE} forge-helm-chart

# Install pip requirements using cache.
# Requirements only reinstalled if requirements file changes
.pip-requirements: &pip-requirements
  variables:
    PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  cache:
    paths:
      - .cache/pip
      - venv/
    key:
      files:
        - $REQUIREMENTS_FILE
  before_script:
    - python -V
    - pip install virtualenv
    - virtualenv venv
    - source venv/bin/activate
    - cd backend
    - pip install -r ${REQUIREMENTS_FILE}
  tags:
    - docker
  except:
    - tags
